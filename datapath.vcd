$date
	Wed Nov 25 13:27:05 2020
$end
$version
	Icarus Verilog
$end
$timescale
	100ps
$end
$scope module testbench $end
$var wire 32 ! instruction [31:0] $end
$var wire 64 " PC [63:0] $end
$var wire 64 # ALUResult [63:0] $end
$var reg 1 $ clk $end
$var reg 1 % reset $end
$scope module Call $end
$var wire 1 $ clk $end
$var wire 1 % reset $end
$var wire 64 & signExtend [63:0] $end
$var wire 64 ' shiftValue [63:0] $end
$var wire 64 ( nextPC [63:0] $end
$var wire 64 ) muxResult [63:0] $end
$var wire 64 * muxDataResult [63:0] $end
$var wire 32 + instruction [31:0] $end
$var wire 1 , Zero $end
$var wire 1 - RegWrite $end
$var wire 64 . ReadData2 [63:0] $end
$var wire 64 / ReadData1 [63:0] $end
$var wire 64 0 ReadData [63:0] $end
$var wire 1 1 MemtoReg $end
$var wire 1 2 MemWrite $end
$var wire 1 3 MemRead $end
$var wire 1 4 Branch $end
$var wire 1 5 ANDResult $end
$var wire 1 6 ALUSrc $end
$var wire 64 7 ALUResult [63:0] $end
$var wire 2 8 ALUOp [1:0] $end
$var wire 4 9 ALUCtrl [3:0] $end
$scope module ALUControl $end
$var wire 3 : Funct3 [2:0] $end
$var wire 7 ; Funct7 [6:0] $end
$var wire 2 < ALUOp [1:0] $end
$var reg 4 = ALUCtrl [3:0] $end
$upscope $end
$scope module ALUValues $end
$var wire 4 > ALUCtrl [3:0] $end
$var wire 64 ? muxResult [63:0] $end
$var wire 64 @ ReadData1 [63:0] $end
$var reg 64 A ALUResult [63:0] $end
$var reg 1 , Zero $end
$upscope $end
$scope module BranchAND $end
$var wire 1 , Zero $end
$var wire 1 4 Branch $end
$var reg 1 5 ANDResult $end
$upscope $end
$scope module Control_Values $end
$var wire 7 B OpCode [6:0] $end
$var reg 2 C ALUOp [1:0] $end
$var reg 1 6 ALUSrc $end
$var reg 1 4 Branch $end
$var reg 1 3 MemRead $end
$var reg 1 2 MemWrite $end
$var reg 1 1 MemtoReg $end
$var reg 1 - RegWrite $end
$upscope $end
$scope module DataMemory $end
$var wire 64 D ALUResult [63:0] $end
$var wire 1 3 MemRead $end
$var wire 1 2 MemWrite $end
$var wire 1 $ clk $end
$var wire 1 % reset $end
$var wire 64 E ReadData2 [63:0] $end
$var reg 64 F ReadData [63:0] $end
$var integer 32 G i [31:0] $end
$upscope $end
$scope module ImmGen $end
$var wire 7 H OpCode [6:0] $end
$var wire 32 I instruction [31:0] $end
$var wire 12 J immSd [11:0] $end
$var wire 12 K immLd [11:0] $end
$var wire 12 L immBeq [11:0] $end
$var reg 64 M signExtend [63:0] $end
$upscope $end
$scope module ImmShiftedOneLeft $end
$var wire 64 N signExtend [63:0] $end
$var reg 64 O result [63:0] $end
$upscope $end
$scope module InstructionMemory $end
$var wire 64 P PC [63:0] $end
$var reg 32 Q instruction [31:0] $end
$upscope $end
$scope module PC_Branch $end
$var wire 1 R ANDBranch $end
$var wire 1 $ clk $end
$var wire 64 S shiftValue [63:0] $end
$var wire 64 T PC [63:0] $end
$var reg 64 U sum [63:0] $end
$upscope $end
$scope module Regs $end
$var wire 5 V ReadReg1 [4:0] $end
$var wire 5 W ReadReg2 [4:0] $end
$var wire 5 X RegWrite [4:0] $end
$var wire 1 - WriteReg $end
$var wire 1 $ clk $end
$var wire 1 % reset $end
$var wire 64 Y WriteData [63:0] $end
$var reg 64 Z ReadData1 [63:0] $end
$var reg 64 [ ReadData2 [63:0] $end
$upscope $end
$scope module muxALU $end
$var wire 1 6 ALUSrc $end
$var wire 64 \ ReadData2 [63:0] $end
$var wire 64 ] signExtend [63:0] $end
$var reg 64 ^ muxResult [63:0] $end
$upscope $end
$scope module muxDataMem $end
$var wire 64 _ ALUResult [63:0] $end
$var wire 1 1 MemtoReg $end
$var wire 64 ` ReadData [63:0] $end
$var reg 64 a muxDataResult [63:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b1000 a
bx `
b1000 _
b1000 ^
b1000 ]
b0 \
b0 [
b0 Z
b1000 Y
b1000 X
b10 W
b0 V
b0 U
b0 T
b10000 S
0R
b1000000111010000100011 Q
b0 P
b10000 O
b1000 N
b1000 M
b100 L
b10 K
b1000 J
b1000000111010000100011 I
b100011 H
b100000 G
bx F
b0 E
b1000 D
b0 C
b100011 B
b1000 A
b0 @
b1000 ?
b10 >
b10 =
b0 <
b0 ;
b111 :
b10 9
b0 8
b1000 7
16
05
04
03
12
01
bx 0
b0 /
b0 .
0-
0,
b1000000111010000100011 +
b1000 *
b1000 )
b0 (
b10000 '
b1000 &
x%
0$
b1000 #
b0 "
b1000000111010000100011 !
$end
#100
b0 0
b0 F
b0 `
b0 *
b0 Y
b0 a
b100000 G
02
13
1-
11
b10000000000 L
b1 J
b1000 K
b11 :
b1 X
b1000 W
b11 H
b11 B
b100000000011000010000011 !
b100000000011000010000011 +
b100000000011000010000011 I
b100000000011000010000011 Q
b100 "
b100 (
b100 P
b100 T
b100 U
1$
#200
0$
#300
1,
b0 #
b0 7
b0 A
b0 D
b0 _
b0 *
b0 Y
b0 a
b0 )
b0 ?
b0 ^
b100000 G
b10 8
b10 <
b10 C
03
01
06
b1 L
b10 J
b0 K
b0 :
b10 X
b0 W
b1 V
b110011 H
b110011 B
b1000000100110011 !
b1000000100110011 +
b1000000100110011 I
b1000000100110011 Q
b1000 "
b1000 (
b1000 P
b1000 T
b1000 U
1$
#400
0$
#500
b10000000000 L
b1 J
b10 K
b1 X
b10 W
b1000001000000010110011 !
b1000001000000010110011 +
b1000001000000010110011 I
b1000001000000010110011 Q
b1100 "
b1100 (
b1100 P
b1100 T
b1100 U
1$
#600
0$
#700
b10000 "
b10000 (
b10000 P
b10000 T
b10000 U
1$
#800
0$
#900
b110 9
b110 =
b110 >
b11000000000 L
b10000000001 J
b10000000010 K
b100000 ;
b1000000001000001000000010110011 !
b1000000001000001000000010110011 +
b1000000001000001000000010110011 I
b1000000001000001000000010110011 Q
b10100 "
b10100 (
b10100 P
b10100 T
b10100 U
1$
#1000
0$
#1100
b11000 "
b11000 (
b11000 P
b11000 T
b11000 U
1$
#1200
0$
#1300
b10 9
b10 =
b10 >
b110 L
b1100 J
b10 K
b0 ;
b1100 X
b1100111 H
b1100111 B
b1000001000011001100111 !
b1000001000011001100111 +
b1000001000011001100111 I
b1000001000011001100111 Q
b11100 "
b11100 (
b11100 P
b11100 T
b11100 U
1$
#1400
0$
#1500
b10000000000 L
b1 J
b1 K
b1 X
b1 W
b110011 H
b110011 B
b100001000000010110011 !
b100001000000010110011 +
b100001000000010110011 I
b100001000000010110011 Q
b100000 "
b100000 (
b100000 P
b100000 T
b100000 U
1$
#1600
0$
#1700
b0 '
b0 O
b0 S
b10 9
b10 =
b10 >
b0 8
b0 <
b0 C
12
0-
16
b0 &
b0 M
b0 N
b0 ]
b0 L
b0 J
b111 :
b0 X
b0 V
b100011 H
b100011 B
b100000111000000100011 !
b100000111000000100011 +
b100000111000000100011 I
b100000111000000100011 Q
b100100 "
b100100 (
b100100 P
b100100 T
b100100 U
1$
#1800
0$
#1900
b0 9
b0 =
b0 >
b10 8
b10 <
b10 C
02
1-
06
b10000000000 L
b1 J
b10 K
b1 X
b10 W
b1 V
b110011 H
b110011 B
b1000001111000010110011 !
b1000001111000010110011 +
b1000001111000010110011 I
b1000001111000010110011 Q
b101000 "
b101000 (
b101000 P
b101000 T
b101000 U
1$
#2000
0$
#2100
b1 9
b1 =
b1 >
b0 K
b110 :
b0 W
b1110000010110011 !
b1110000010110011 +
b1110000010110011 I
b1110000010110011 Q
b101100 "
b101100 (
b101100 P
b101100 T
b101100 U
1$
#2200
0$
#2300
b10 9
b10 =
b10 >
b0 8
b0 <
b0 C
12
0-
16
b0 L
b0 J
b1 K
b111 :
b0 X
b1 W
b0 V
b100011 H
b100011 B
b100000111000000100011 !
b100000111000000100011 +
b100000111000000100011 I
b100000111000000100011 Q
b110000 "
b110000 (
b110000 P
b110000 T
b110000 U
1$
#2400
0$
#2500
0,
bx *
bx Y
bx a
b100000 G
bx #
bx 7
bx A
bx D
bx _
bx .
bx E
bx [
bx \
bx /
bx @
bx Z
bx0000000000000 '
bx0000000000000 O
bx0000000000000 S
bx000000000000 )
bx000000000000 ?
bx000000000000 ^
bx L
bx J
bx K
bx :
bx ;
bx X
bx W
bx V
bx H
bx B
bx000000000000 &
bx000000000000 M
bx000000000000 N
bx000000000000 ]
bx !
bx +
bx I
bx Q
b110100 "
b110100 (
b110100 P
b110100 T
b110100 U
1$
#2600
0$
#2700
b111000 "
b111000 (
b111000 P
b111000 T
b111000 U
1$
#2800
0$
#2900
b111100 "
b111100 (
b111100 P
b111100 T
b111100 U
1$
#3000
0$
